//@version=5
indicator("SSL Hybrid Benimki Codiff Special Part_1", overlay=true)

//ATR
atrlen = input(14, 'ATR Period')
mult = input.float(1, 'ATR Multi', step=0.1)
smoothing = input.string(title='ATR Smoothing', defval='WMA', options=['RMA', 'SMA', 'EMA', 'WMA'])

// Get only symbol
only_symbol(s) =>
    array.get(str.split(s, ":"), 1)

ma_function(source, atrlen) =>
    if smoothing == 'RMA'
        ta.rma(source, atrlen)
    else
        if smoothing == 'SMA'
            ta.sma(source, atrlen)
        else
            if smoothing == 'EMA'
                ta.ema(source, atrlen)
            else
                ta.wma(source, atrlen)
atr_slen = ma_function(ta.tr(true), atrlen)


SSL2Type = 'JMA'
len2 = 5
//
SSL3Type = 'HMA'
len3 = 15
src = close

////BASELINE / SSL1 / SSL2 / EXIT MOVING AVERAGE VALUES
maType = 'HMA'
len = 60


ma(type, src, len) =>
    float result = 0
    if type == 'HMA'  // Hull
        result := ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len)))
        result
    result


screener_func() =>
    ///SSL 1 and SSL2
    emaHigh = ma(maType, high, len)
    emaLow = ma(maType, low, len)

    maHigh = ma(SSL2Type, high, len2)
    maLow = ma(SSL2Type, low, len2)

    //SSL2 VALUES
    Hlv2 = int(na)
    Hlv2 := close > maHigh ? 1 : close < maLow ? -1 : Hlv2[1]
    sslDown2 = Hlv2 < 0 ? maHigh : maLow

    ///EXIT
    ExitHigh = ma(SSL3Type, high, len3)
    ExitLow = ma(SSL3Type, low, len3)

    BBMC = ma(maType, close, len)

    ///Keltner Baseline Channel
    useTrueRange = input.bool(true)
    multy = input.float(0.2, step=0.05, title='Base Channel Multiplier')
    Keltma = ma(maType, src, len)
    range_1 = useTrueRange ? ta.tr : high - low
    rangema = ta.ema(range_1, len)
    upperk = Keltma + rangema * multy
    lowerk = Keltma - rangema * multy

    //EXIT VALUES
    Hlv3 = int(na)
    Hlv3 := close > ExitHigh ? 1 : close < ExitLow ? -1 : Hlv3[1]
    sslExit = Hlv3 < 0 ? ExitHigh : ExitLow
    base_cross_Long = ta.crossover(close, sslExit)
    base_cross_Short = ta.crossover(sslExit, close)
    codiff = base_cross_Long ? 1 : base_cross_Short ? -1 : na


    atr_crit = input.float(0.9, step=0.1, title='Continuation ATR Criteria')
    upper_half = atr_slen * atr_crit + close
    lower_half = close - atr_slen * atr_crit
    buy_inatr = lower_half < sslDown2
    buy_cont = close > BBMC and close > sslDown2
    buyContinuation = buy_inatr and buy_cont
    sslExitSell = ta.crossover(close, sslExit)
    sslExitBuy = ta.crossover(sslExit, close)
    baseLineBuyAlertCond = ta.crossover(close, upperk)
    baseLineSellAlertCond = ta.crossover(lowerk, close)

    [math.round_to_mintick(close), buyContinuation, baseLineBuyAlertCond, baseLineSellAlertCond, codiff, sslExitSell, sslExitBuy]/////////////
// SYMBOLS //
// Part 1

u01 = input.bool(true,  title = "", group = 'Symbols', inline = 's01')
u02 = input.bool(true,  title = "", group = 'Symbols', inline = 's02')
// SYMBOLS //
// Part 1

s01 = input.symbol('LOKABUSD', group = 'Symbols', inline = 's01')
s02 = input.symbol('SOLBUSD', group = 'Symbols', inline = 's02')
// Security calls 
//Part 1

[current_price01, buyContinuation01, baseLineBuyAlertCond01, baseLineSellAlertCond01, codiff_plot01, sslExitSell01, sslExitBuy01] = request.security(s01, timeframe.period, screener_func())
[current_price02, buyContinuation02, baseLineBuyAlertCond02, baseLineSellAlertCond02, codiff_plot02, sslExitSell02, sslExitBuy02] = request.security(s02, timeframe.period, screener_func())

/////////////
// ARRAYS //

s_arr   = array.new_string(0)
u_arr   = array.new_bool(0)
current_price_arr   = array.new_float(0)
buy_continuation_arr   = array.new_bool(0)
baseLineBuyAlertCond_arr   = array.new_bool(0)
baseLineSellAlertCond_arr   = array.new_bool(0)
codiff_plot_arr   = array.new_bool(0)
sslExitSell_arr   = array.new_bool(0)
sslExitBuy_arr   = array.new_bool(0)
// Add Symbols 
array.push(s_arr, only_symbol(s01))
array.push(s_arr, only_symbol(s02))
// FLAGS 
array.push(u_arr, u01)
array.push(u_arr, u02)
// Current price 
array.push(current_price_arr, current_price01)
array.push(current_price_arr, current_price02)
// Buy continuation 
array.push(buy_continuation_arr, buyContinuation01)
array.push(buy_continuation_arr, buyContinuation02)
// Baseline BUY alert condition 
array.push(baseLineBuyAlertCond_arr, baseLineBuyAlertCond01)
array.push(baseLineBuyAlertCond_arr, baseLineBuyAlertCond02)
// Baseline SELL alert condition 
array.push(baseLineSellAlertCond_arr, baseLineSellAlertCond01)
array.push(baseLineSellAlertCond_arr, baseLineSellAlertCond02)
// Condition for plotting 
array.push(codiff_plot_arr, codiff_plot01)
array.push(codiff_plot_arr, codiff_plot02)
// SSL exit sell 
array.push(sslExitSell_arr, sslExitSell01)
array.push(sslExitSell_arr, sslExitSell02)
// SSL exit buy 
array.push(sslExitBuy_arr, sslExitBuy01)
array.push(sslExitBuy_arr, sslExitBuy02)
if barstate.islast
    for i = 0 to array.size(u_arr) - 1
        if array.get(u_arr, i)
            if array.get(codiff_plot_arr, i) == 1
                alertstring = '{"symbol": "' + array.get(s_arr, i) + '","side": "BUY", "cond": "codiff_spe", "tf": "' + timeframe.period + '", "tv_price": "' + str.tostring(array.get(current_price_arr, i)) + '"}'
                alert(alertstring, alert.freq_once_per_bar)

            if array.get(codiff_plot_arr, i) == -1
                alertstring = '{"symbol": "' + array.get(s_arr, i) + '","side": "SELL", "cond": "codiff_spe", "tf": "' + timeframe.period + '", "tv_price": "' + str.tostring(array.get(current_price_arr, i)) + '"}'
                alert(alertstring, alert.freq_once_per_bar)